package gov.nih.nhlbi.abdesigner;

/*
 * AbDesigner.java
 *
 * Created on September 15, 2008, 11:21 PM
 */

import java.awt.Color;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;

/**
 *
 * @author  Pisitkun
 */
public class AbDesigner extends javax.swing.JFrame {
    
    Object inputType = "Gene Symbol";
    Object selectedSpecies = "HUMAN";
    Object selectedAccession = "Swiss-Prot";
    Object method = "AbDesigner";
    Object uniquenessSpecies = "HUMAN";
    final String[] structure = {" ", "alpha helix", "beta sheet", "strong beta turn", "weak beta turn"};
    private ArrayList<ArrayList<String>> human2DArrayList;
    private ArrayList<ArrayList<String>> rat2DArrayList;
    private ArrayList<ArrayList<String>> mouse2DArrayList;
    private boolean databaseLoaded;
    private HashMap<String, String> accessionLocusMap;
    private HashMap<String, String> geneLocusMap;
    private HashMap<String, String> locusFeaturesMap;
    private HashMap<String, String> locusSegmaskerMap;
    private final double MAX_KD = 4.5;
    private final double MIN_KD = -4.5;
    private final double TAIL_BONUS = 1.5;
    private final int UNIQUENESS_NUMBER = 3;
    private final int SPECIES_NUMBER = 3;
    
    /** Creates new form AbDesigner */
    public AbDesigner() {
        initComponents();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        inputTypeLabel = new javax.swing.JLabel();
        FASTARadioButton = new javax.swing.JRadioButton();
        accessionNumberRadioButton = new javax.swing.JRadioButton();
        geneInputRadioButton = new javax.swing.JRadioButton();
        speciesComboBox = new javax.swing.JComboBox();
        submitButton = new javax.swing.JButton();
        clearInputButton = new javax.swing.JButton();
        resetButton = new javax.swing.JButton();
        saveButton = new javax.swing.JButton();
        copyButton = new javax.swing.JButton();
        clearOutputButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        outputTextArea = new javax.swing.JTextArea();
        jProgressBar = new javax.swing.JProgressBar();
        progressLabel = new javax.swing.JLabel();
        spanSettingLabel = new javax.swing.JLabel();
        spanSettingSpinner = new javax.swing.JSpinner();
        methodComboBox = new javax.swing.JComboBox();
        methodLabel = new javax.swing.JLabel();
        inputLabel = new javax.swing.JLabel();
        accessionComboBox = new javax.swing.JComboBox();
        esblLabel = new javax.swing.JLabel();
        contactLabel = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        inputTextArea = new javax.swing.JTextArea();
        uniquenessSpeciesLabel = new javax.swing.JLabel();
        uniquenessSpeciesComboBox = new javax.swing.JComboBox();
        matchSpanLabel = new javax.swing.JLabel();
        matchSpanSpinner = new javax.swing.JSpinner();
        entryNameRadioButton = new javax.swing.JRadioButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("NHLBI AbDesigner");
        setIconImage(new ImageIcon(getClass().getResource("NHLBI.jpg")).getImage());

        inputTypeLabel.setText("Select Input Type:");

        buttonGroup1.add(FASTARadioButton);
        FASTARadioButton.setText("FASTA Amino Acid Sequence");
        FASTARadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FASTARadioButtonActionPerformed(evt);
            }
        });

        buttonGroup1.add(accessionNumberRadioButton);
        accessionNumberRadioButton.setText("Accession Number");
        accessionNumberRadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                accessionNumberRadioButtonActionPerformed(evt);
            }
        });

        buttonGroup1.add(geneInputRadioButton);
        geneInputRadioButton.setSelected(true);
        geneInputRadioButton.setText("Gene Symbol");
        geneInputRadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                geneInputRadioButtonActionPerformed(evt);
            }
        });

        speciesComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "HUMAN", "RAT", "MOUSE" }));
        speciesComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                speciesComboBoxActionPerformed(evt);
            }
        });

        submitButton.setText("Submit");
        submitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                submitButtonActionPerformed(evt);
            }
        });

        clearInputButton.setText("Clear");
        clearInputButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearInputButtonActionPerformed(evt);
            }
        });

        resetButton.setText("Reset");
        resetButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetButtonActionPerformed(evt);
            }
        });

        saveButton.setText("Save");
        saveButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveButtonActionPerformed(evt);
            }
        });

        copyButton.setText("Copy");
        copyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                copyButtonActionPerformed(evt);
            }
        });

        clearOutputButton.setText("Clear");
        clearOutputButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearOutputButtonActionPerformed(evt);
            }
        });

        outputTextArea.setColumns(20);
        outputTextArea.setRows(5);
        outputTextArea.setCursor(new java.awt.Cursor(java.awt.Cursor.TEXT_CURSOR));
        jScrollPane1.setViewportView(outputTextArea);

        progressLabel.setText("Progress");

        spanSettingLabel.setText("Peptide Length:");

        spanSettingSpinner.setModel(new javax.swing.SpinnerNumberModel(15, 5, 25, 1));

        methodComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "AbDesigner", "Kyte-Doolittle", "Chou-Fasman", "Modified CF", "Region/Site" }));
        methodComboBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                methodComboBoxItemStateChanged(evt);
            }
        });

        methodLabel.setText("Select Method:");

        inputLabel.setText("Enter Input:");

        accessionComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Swiss-Prot", "Others" }));
        accessionComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                accessionComboBoxActionPerformed(evt);
            }
        });

        esblLabel.setFont(new java.awt.Font("Tahoma", 2, 11));
        esblLabel.setForeground(new java.awt.Color(0, 0, 255));
        esblLabel.setText("<html>Created by Epithelial Systems Biology Laboratory, NHLBI, NIH ");
        esblLabel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                esblLabelMouseClicked(evt);
            }
        });

        contactLabel.setFont(new java.awt.Font("Tahoma", 2, 11));
        contactLabel.setForeground(new java.awt.Color(0, 0, 255));
        contactLabel.setText("<html>Click here to contact us ");
        contactLabel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                contactLabelMouseClicked(evt);
            }
        });

        inputTextArea.setColumns(20);
        inputTextArea.setRows(5);
        jScrollPane2.setViewportView(inputTextArea);

        uniquenessSpeciesLabel.setText("Species:");

        uniquenessSpeciesComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "HUMAN", "RAT", "MOUSE" }));
        uniquenessSpeciesComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uniquenessSpeciesComboBoxActionPerformed(evt);
            }
        });

        matchSpanLabel.setText("Epitope Length:");

        matchSpanSpinner.setModel(new javax.swing.SpinnerNumberModel(7, 5, 25, 1));

        buttonGroup1.add(entryNameRadioButton);
        entryNameRadioButton.setText("Swiss-Prot Entry Name");
        entryNameRadioButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                entryNameRadioButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 648, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(esblLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(contactLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 169, Short.MAX_VALUE)
                        .addComponent(saveButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(copyButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(clearOutputButton))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(inputLabel)
                            .addComponent(methodLabel)
                            .addComponent(inputTypeLabel))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 555, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(methodComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(spanSettingLabel)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(spanSettingSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(matchSpanLabel)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(matchSpanSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(37, 37, 37)
                                .addComponent(uniquenessSpeciesLabel)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(uniquenessSpeciesComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(geneInputRadioButton)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addComponent(speciesComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                    .addComponent(entryNameRadioButton))
                                .addGap(40, 40, 40)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(FASTARadioButton)
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(accessionNumberRadioButton)
                                        .addGap(6, 6, 6)
                                        .addComponent(accessionComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addGap(167, 167, 167))))
                    .addComponent(jProgressBar, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 648, Short.MAX_VALUE)
                    .addComponent(progressLabel)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(submitButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(clearInputButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(resetButton)))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {matchSpanSpinner, spanSettingSpinner, uniquenessSpeciesComboBox});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(inputTypeLabel)
                    .addComponent(geneInputRadioButton)
                    .addComponent(accessionNumberRadioButton)
                    .addComponent(speciesComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(accessionComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(FASTARadioButton)
                    .addComponent(entryNameRadioButton))
                .addGap(7, 7, 7)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(inputLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(methodLabel)
                    .addComponent(methodComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(spanSettingSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(matchSpanSpinner, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(uniquenessSpeciesComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(spanSettingLabel)
                    .addComponent(matchSpanLabel)
                    .addComponent(uniquenessSpeciesLabel))
                .addGap(41, 41, 41)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(resetButton)
                    .addComponent(clearInputButton)
                    .addComponent(submitButton))
                .addGap(15, 15, 15)
                .addComponent(progressLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jProgressBar, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 147, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(clearOutputButton)
                        .addComponent(copyButton)
                        .addComponent(saveButton))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(esblLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(contactLabel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

private void submitButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_submitButtonActionPerformed
    progressLabel.setForeground(Color.blue);
    progressLabel.setText("Processing...");
    jProgressBar.setValue(0);
        new Thread(){
            @Override
        public void run() {
                try {
                    submit();
                } catch (IOException ex) {
                    Logger.getLogger(AbDesigner.class.getName()).log(Level.SEVERE, null, ex);
                } catch (ClassNotFoundException ex) {
                    Logger.getLogger(AbDesigner.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }.start();
}//GEN-LAST:event_submitButtonActionPerformed

private void FASTARadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FASTARadioButtonActionPerformed
    inputType = "FASTA";
}//GEN-LAST:event_FASTARadioButtonActionPerformed

private void geneInputRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_geneInputRadioButtonActionPerformed
    inputType = "Gene Symbol";
}//GEN-LAST:event_geneInputRadioButtonActionPerformed

private void accessionNumberRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_accessionNumberRadioButtonActionPerformed
    inputType = "Accession Number";
}//GEN-LAST:event_accessionNumberRadioButtonActionPerformed

private void clearInputButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearInputButtonActionPerformed
    inputTextArea.setText("");
    progressLabel.setForeground(Color.black);
    progressLabel.setText("Progress");
    jProgressBar.setValue(0);
}//GEN-LAST:event_clearInputButtonActionPerformed

private void resetButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetButtonActionPerformed
    inputTextArea.setText("");
    outputTextArea.setText("");
    progressLabel.setForeground(Color.black);
    progressLabel.setText("Progress");
    jProgressBar.setValue(0);
}//GEN-LAST:event_resetButtonActionPerformed

private void saveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveButtonActionPerformed
    JFileChooser fc = new JFileChooser();
    int returnVal = fc.showSaveDialog(AbDesigner.this);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        PrintStream p = null;
        try {
            File file = fc.getSelectedFile();
            p = new PrintStream(new BufferedOutputStream(new FileOutputStream(file)));
            p.println(outputTextArea.getText());
            progressLabel.setText(file + " saved");
        } catch (FileNotFoundException ex) {
            Logger.getLogger(AbDesigner.class.getName()).log(Level.SEVERE, null, ex);
        } finally {
            if (p != null) {
                p.close();
            }
        }
    }
}//GEN-LAST:event_saveButtonActionPerformed

private void copyButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_copyButtonActionPerformed
    outputTextArea.requestFocusInWindow();
    outputTextArea.selectAll();
    Clipboard cb =
      Toolkit.getDefaultToolkit().
      getSystemClipboard();
    String s = outputTextArea.getText();
    StringSelection contents =
      new StringSelection(s);
    cb.setContents(contents, null);
}//GEN-LAST:event_copyButtonActionPerformed

private void clearOutputButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearOutputButtonActionPerformed
    outputTextArea.setText("");
    progressLabel.setForeground(Color.black);
    progressLabel.setText("Progress");
    jProgressBar.setValue(0);
}//GEN-LAST:event_clearOutputButtonActionPerformed

private void methodComboBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_methodComboBoxItemStateChanged
    method = methodComboBox.getSelectedItem();
    if (method == "AbDesigner") {
        spanSettingLabel.setEnabled(true);
        spanSettingSpinner.setEnabled(true);
        spanSettingSpinner.setModel(new javax.swing.SpinnerNumberModel(15, 5, 25, 1));
        FASTARadioButton.setEnabled(true);
        matchSpanLabel.setEnabled(true);
        matchSpanSpinner.setEnabled(true);
        uniquenessSpeciesLabel.setEnabled(true);
        uniquenessSpeciesComboBox.setEnabled(true);
    } else {
        if (method == "Region/Site") {
            spanSettingLabel.setEnabled(false);
            spanSettingSpinner.setEnabled(false);
            FASTARadioButton.setEnabled(false);
        }
        if (method == "Kyte-Doolittle") {
            spanSettingLabel.setEnabled(true);
            spanSettingSpinner.setEnabled(true);
            spanSettingSpinner.setModel(new javax.swing.SpinnerNumberModel(7, 3, 21, 2));
            FASTARadioButton.setEnabled(true);
        }
        if ((method == "Chou-Fasman") || (method == "Modified CF")) {
            spanSettingSpinner.setValue(4);
            spanSettingLabel.setEnabled(false);
            spanSettingSpinner.setEnabled(false);
            FASTARadioButton.setEnabled(true);
        }
        matchSpanLabel.setEnabled(false);
        matchSpanSpinner.setEnabled(false);
        uniquenessSpeciesLabel.setEnabled(false);
        uniquenessSpeciesComboBox.setEnabled(false);
    }
}//GEN-LAST:event_methodComboBoxItemStateChanged

private void accessionComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_accessionComboBoxActionPerformed
    selectedAccession = accessionComboBox.getSelectedItem();
    accessionNumberRadioButton.setSelected(true);
    inputType = "Accession Number";
}//GEN-LAST:event_accessionComboBoxActionPerformed

private void speciesComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_speciesComboBoxActionPerformed
    selectedSpecies = speciesComboBox.getSelectedItem();
    geneInputRadioButton.setSelected(true);
    inputType = "Gene Symbol";
    uniquenessSpeciesComboBox.setSelectedItem(selectedSpecies);
}//GEN-LAST:event_speciesComboBoxActionPerformed

private void contactLabelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_contactLabelMouseClicked
    try {
        Runtime.getRuntime().exec("cmd.exe /C start https://dirweb.nhlbi.nih.gov/Centers/CBPC/LKEM_G/LKEM/Pages/default.aspx");
    } catch (IOException ex) {
        Logger.getLogger(AbDesigner.class.getName()).log(Level.SEVERE, null, ex);
    }
}//GEN-LAST:event_contactLabelMouseClicked

private void esblLabelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_esblLabelMouseClicked
    try {
        Runtime.getRuntime().exec("cmd.exe /C start https://dirweb.nhlbi.nih.gov/Centers/CBPC/LKEM_G/LKEM/Pages/Antibodydesignsoftware.aspx");
    } catch (IOException ex) {
        Logger.getLogger(AbDesigner.class.getName()).log(Level.SEVERE, null, ex);
    }
}//GEN-LAST:event_esblLabelMouseClicked

private void entryNameRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_entryNameRadioButtonActionPerformed
    inputType = "Entry Name";
}//GEN-LAST:event_entryNameRadioButtonActionPerformed

private void uniquenessSpeciesComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uniquenessSpeciesComboBoxActionPerformed
    uniquenessSpecies = uniquenessSpeciesComboBox.getSelectedItem();
}//GEN-LAST:event_uniquenessSpeciesComboBoxActionPerformed

private void submit() throws IOException, ClassNotFoundException {
    //Read all databases
    if (!databaseLoaded) {
        readDatabase();
    }
    //Get input
    String allInput = inputTextArea.getText().toUpperCase();
    int numberInput = 0;
    if (inputType == "FASTA") {
        allInput = allInput.replaceAll("\\s", "");
        numberInput = 1;
    } else {
        numberInput = allInput.split("\\s").length;
    }
    //Scan input
    Scanner s = null;
    int progress = 0;
    progressLabel.setForeground(Color.blue);
    try {        
        s = new Scanner(new BufferedReader(new StringReader(allInput)));
        String inputID = null;
        int spanSetting = ((Integer) spanSettingSpinner.getValue()).intValue();
        while (s.hasNext()) {
            inputID = s.next();
            String inputSequence = null;
            int inputSequenceLength = 0;
            int numberOfSpan = 0;
            if (method == "Kyte-Doolittle" || method == "Chou-Fasman" || method == "Modified CF") {
                if (inputType == "Gene Symbol") {
                    progressLabel.setText("Calling RefSeq...");
                    String accessionRefSeq = EntrezUtilities.callRefSeq(inputID, selectedSpecies);
                    progressLabel.setText("Getting FASTA...");
                    inputSequence = EntrezUtilities.callFASTA(accessionRefSeq);
                } else if (inputType == "Accession Number") {
                    progressLabel.setText("Getting FASTA...");
                    inputSequence = EntrezUtilities.callFASTA(inputID);
                } else if (inputType == "FASTA") {
                    inputSequence = inputID;
                }
                if (inputSequence == null) {
                    outputTextArea.append("Invalid input\n");
                    outputTextArea.setCaretPosition(outputTextArea.getDocument().getLength());
                } else {
                    progressLabel.setText("Processing...");
                    inputSequenceLength = inputSequence.length();
                    numberOfSpan = inputSequenceLength - spanSetting + 1;
                    if (method == "Kyte-Doolittle") {
                        getKyteDoolittle(inputID, inputSequence, spanSetting, inputSequenceLength, numberOfSpan);
                    } else if (method == "Chou-Fasman") {
                        getChouFasman(inputID, inputSequence, spanSetting, inputSequenceLength, numberOfSpan);
                    } else if (method == "Modified CF") {
                        getModifiedChouFasman(inputID, inputSequence, spanSetting, inputSequenceLength, numberOfSpan);
                    }
                }
            } else {
                String swissProtContent = null;
                if (inputType == "FASTA") {
                    inputSequence = inputID;
                    progressLabel.setText("Processing...");
                    inputSequenceLength = inputSequence.length();
                    numberOfSpan = inputSequenceLength - spanSetting + 1;
                    if (method == "AbDesigner") {
                        getAbDesigner(inputID, "", inputSequence, spanSetting, inputSequenceLength, numberOfSpan);
                    }
                } else {
                    String entryName = null;
                    if (inputType == "Gene Symbol") {
                        progressLabel.setText("Getting Swiss-Prot Entry Name...");
                        entryName = geneLocusMap.get(inputID + "_" + selectedSpecies);
                    } else if (inputType == "Accession Number") {
                        if (selectedAccession == "Swiss-Prot") {
                            progressLabel.setText("Getting Swiss-Prot Entry Name...");
                            entryName = accessionLocusMap.get(inputID);
                        } else {
//                            progressLabel.setText("Calling Swiss-Prot...");
//                            String str = EntrezUtilities.callNCBIText(inputID);
//                            String gene = EntrezUtilities.getGeneName(str);
//                            String species = EntrezUtilities.getSpecies(str);
//                            if (gene != null && species != null) {
//                                gi = EntrezUtilities.callSwissProt(gene, species.replace(" ", "+"));
//                            }
                        }
                    } else { //inputType == "Entry Name"
                        entryName = inputID;
                    }
                    if (entryName != null) {
                        progressLabel.setText("Getting Swiss-Prot Features...");
                        swissProtContent = locusFeaturesMap.get(entryName);
                        progressLabel.setText("Getting FASTA Sequence...");
                        inputSequence = locusSegmaskerMap.get(entryName);
                        progressLabel.setText("Processing...");
                        inputSequenceLength = inputSequence.length();
                        numberOfSpan = inputSequenceLength - spanSetting + 1;
                        if (method == "AbDesigner") {
                            getAbDesigner(entryName, swissProtContent, inputSequence, spanSetting, inputSequenceLength, numberOfSpan);
                        } else {
                            getRegionSite(entryName, swissProtContent, inputSequence, inputSequenceLength);
                        }
                    } else {
                        outputTextArea.append("Invalid input\n");
                        outputTextArea.setCaretPosition(outputTextArea.getDocument().getLength());
                    }
                }
            }
            //Progress bar
            progress++;
            int percentProgress = (progress * 100)/numberInput;
            jProgressBar.setValue(percentProgress);
        }
    } finally {
        if (s != null) {
            s.close();
        }
    } //Close finally
        
    progressLabel.setForeground(Color.red);
    progressLabel.setText("Completed");
}

    /**
    * @param args the command line arguments
    */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AbDesigner().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JRadioButton FASTARadioButton;
    private javax.swing.JComboBox accessionComboBox;
    private javax.swing.JRadioButton accessionNumberRadioButton;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JButton clearInputButton;
    private javax.swing.JButton clearOutputButton;
    private javax.swing.JLabel contactLabel;
    private javax.swing.JButton copyButton;
    private javax.swing.JRadioButton entryNameRadioButton;
    private javax.swing.JLabel esblLabel;
    private javax.swing.JRadioButton geneInputRadioButton;
    private javax.swing.JLabel inputLabel;
    private javax.swing.JTextArea inputTextArea;
    private javax.swing.JLabel inputTypeLabel;
    private javax.swing.JProgressBar jProgressBar;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JLabel matchSpanLabel;
    private javax.swing.JSpinner matchSpanSpinner;
    private javax.swing.JComboBox methodComboBox;
    private javax.swing.JLabel methodLabel;
    private javax.swing.JTextArea outputTextArea;
    private javax.swing.JLabel progressLabel;
    private javax.swing.JButton resetButton;
    private javax.swing.JButton saveButton;
    private javax.swing.JLabel spanSettingLabel;
    private javax.swing.JSpinner spanSettingSpinner;
    private javax.swing.JComboBox speciesComboBox;
    private javax.swing.JButton submitButton;
    private javax.swing.JComboBox uniquenessSpeciesComboBox;
    private javax.swing.JLabel uniquenessSpeciesLabel;
    // End of variables declaration//GEN-END:variables

//Get Kyte-Doolittle
    private void getKyteDoolittle(String inputID, String inputSequence, int spanSetting, int inputSequenceLength, int numberOfSpan) {
        int startSpan = 0;
        int endSpan = 0;
        outputTextArea.append("Input: " + inputID + "\tAmino Acid Number: " + inputSequenceLength + "\tPeptide Span Setting: " + spanSetting + "\n" + inputSequence + "\n");
        outputTextArea.append("Position\t" + "Residue\t" + "Average hydropathy index\n");
        int firstSpanCenter = (spanSetting + 1)/2;
        System.out.println(firstSpanCenter);
        //preSpanResidue
        for (int i = 1; i < ((spanSetting + 1)/2); i++) {
            char preSpanResidue = inputSequence.charAt(i - 1);
            outputTextArea.append(i + "\t" + preSpanResidue + "\n");
        }
        //getHydropathy
        for (int i = 0; i < numberOfSpan; i++) {
            endSpan = startSpan + spanSetting;
            int spanCenter = firstSpanCenter++;
            char centerResidue = inputSequence.charAt(spanCenter-1);
            double hydropathy = KyteDoolittle.getHydropathy(inputSequence.substring(startSpan, endSpan), spanSetting);
            outputTextArea.append(spanCenter + "\t" + centerResidue + "\t" + hydropathy + "\n");
            startSpan++;
        }
        //postSpanResidue
        if (spanSetting % 2 == 1) {
            for (int i = 1; i < ((spanSetting + 1)/2); i++) {
                char postSpanResidueKD = inputSequence.charAt(inputSequenceLength - ((spanSetting + 1)/2) + i);
                outputTextArea.append(inputSequenceLength - ((spanSetting + 1)/2) + i + 1 + "\t" + postSpanResidueKD + "\n");
            }
        } else {
            for (int i = 0; i < ((spanSetting + 1)/2); i++) {
                char postSpanResidueKD = inputSequence.charAt(inputSequenceLength - ((spanSetting + 1)/2) + i);
                outputTextArea.append(inputSequenceLength - ((spanSetting + 1)/2) + i + 1 + "\t" + postSpanResidueKD + "\n");
            }
        }
    }

//Get Chou-Fasman
    private void getChouFasman(String inputID, String inputSequence, int spanSetting, int inputSequenceLength, int numberOfSpan) {
        int startSpan = 0;
        int endSpan = 0;
        outputTextArea.append("Input: " + inputID + "\tAmino Acid Number: " + inputSequenceLength + "\tPeptide Span Setting: " + spanSetting + "\n" + inputSequence + "\n");
        outputTextArea.append("Position\t" + "Residue\t" + "a\t" + "b\t" + "<Pa>\t" + "<Pb>\t" + "<Pt>\t" + "<pt>\t" + "Prediction\n");
        for (int i = 0; i < numberOfSpan; i++) {
            endSpan = startSpan + spanSetting;
            String eachSpan = inputSequence.substring(startSpan, endSpan);
            char eachResidue = inputSequence.charAt(i);
            String a = ChouFasman.getAlpha(eachResidue);
            String b = ChouFasman.getBeta(eachResidue);
            double averagePa = ChouFasman.getPa(eachSpan, 4);
            double averagePb = ChouFasman.getPb(eachSpan, 4);
            double averagePt = ChouFasman.getPt(eachSpan, 4);
            double bendProbability = ChouFasman.getBendProbability(eachSpan);
            String prediction = "";
            if ((averagePa > 100.0) && (averagePa > averagePb) && (averagePa > averagePt)) {
                prediction = "alpha helix";
            }
            if ((averagePb > 100.0) && (averagePb > averagePa) && (averagePb > averagePt)) {
                prediction = "beta sheet";
            }
            if (((averagePt > 100.0) || (bendProbability > 0.000075)) && (averagePt > averagePa) && (averagePt > averagePb)) {
                if ((averagePt > 100.0) && (bendProbability > 0.000075)) {
                prediction = "strong beta turn";
                } else {
                prediction = "weak beta turn";
                }
            }
            outputTextArea.append(i + 1 + "\t" + eachResidue + "\t" + a + "\t" + b + "\t" + averagePa + "\t" + averagePb + "\t" + averagePt + "\t" + bendProbability + "\t" + prediction + "\n");
            startSpan++;
        }
        //postSpanResidue
        for (int i = 1; i < spanSetting; i++) {
            char postSpanResidueCF = inputSequence.charAt(inputSequenceLength - spanSetting + i);
            String aPost = ChouFasman.getAlpha(postSpanResidueCF);
            String bPost = ChouFasman.getBeta(postSpanResidueCF);
            outputTextArea.append(inputSequenceLength - spanSetting + i + 1 + "\t" + postSpanResidueCF + "\t" + aPost + "\t" + bPost + "\n");
        }
    }

//Get Modified Chou-Fasman
    private void getModifiedChouFasman(String inputID, String inputSequence, int spanSetting, int inputSequenceLength, int numberOfSpan) {
        int startSpan = 0;
        int endSpan = 0;
        outputTextArea.append("Input: " + inputID + "\tAmino Acid Number: " + inputSequenceLength + "\tPeptide Span Setting: " + spanSetting + "\n" + inputSequence + "\n");
        outputTextArea.append("Position\t" + "Residue\t" + "a\t" + "b\t" + "<Pa>\t" + "<Pb>\t" + "<Pt>\t" + "<pt>\t" + "Prediction\n");
        double bendProbability = 0;
        //preSpanResidue
        for (int i = 1; i < (spanSetting - 1); i++) {
            char preSpanResidueCF = inputSequence.charAt(i - 1);
            String aPre = ChouFasman.getAlpha(preSpanResidueCF);
            String bPre = ChouFasman.getBeta(preSpanResidueCF);
            bendProbability = ChouFasman.getBendProbability(inputSequence.substring(i - 1, i + 3));
            outputTextArea.append(i + "\t" + preSpanResidueCF + "\t" + aPre + "\t" + bPre + "\t" + "\t" + "\t" + "\t" + bendProbability + "\n");
        }
        for (int i = 0; i < (numberOfSpan - 2); i++) {
            endSpan = startSpan + spanSetting;
            String eachSpan1 = inputSequence.substring(startSpan, endSpan);
            String eachSpan2 = inputSequence.substring(startSpan + 1, endSpan + 1);
            String eachSpan3 = inputSequence.substring(startSpan + 2, endSpan + 2);
            char eachResidue = inputSequence.charAt(i + 2);
            String a = ChouFasman.getAlpha(eachResidue);
            String b = ChouFasman.getBeta(eachResidue);
            double averagePa = (ChouFasman.getPa(eachSpan1, 4) + ChouFasman.getPa(eachSpan2, 4))/2;
            double averagePb = (ChouFasman.getPb(eachSpan1, 4) + ChouFasman.getPb(eachSpan2, 4))/2;
            double averagePt = (ChouFasman.getPt(eachSpan1, 4) + ChouFasman.getPt(eachSpan2, 4))/2;
            bendProbability = ChouFasman.getBendProbability(eachSpan3);
            String prediction = "";
            if ((averagePa > 100.0) && (averagePa > averagePb) && (averagePa > averagePt)) {
                prediction = "alpha helix";
            }
            if ((averagePb > 100.0) && (averagePb > averagePa) && (averagePb > averagePt)) {
                prediction = "beta sheet";
            }
            if (((averagePt > 100.0) || (bendProbability > 0.000075)) && (averagePt > averagePa) && (averagePt > averagePb)) {
                if ((averagePt > 100.0) && (bendProbability > 0.000075)) {
                prediction = "strong beta turn";
                } else {
                prediction = "weak beta turn";
                }
            }
            outputTextArea.append(i + 3 + "\t" + eachResidue + "\t" + a + "\t" + b + "\t" + averagePa + "\t" + averagePb + "\t" + averagePt + "\t" + bendProbability + "\t" + prediction + "\n");
            startSpan++;
        }
        //postSpanResidue
        for (int i = 1; i < spanSetting; i++) {
            char postSpanResidueCF = inputSequence.charAt(inputSequenceLength - spanSetting + i);
            String aPost = ChouFasman.getAlpha(postSpanResidueCF);
            String bPost = ChouFasman.getBeta(postSpanResidueCF);
            outputTextArea.append(inputSequenceLength - spanSetting + i + 1 + "\t" + postSpanResidueCF + "\t" + aPost + "\t" + bPost + "\n");
        }
    }

//Get Region/Site
    private void getRegionSite(String inputID, String swissProtContent, String inputSequence, int inputSequenceLength) {
        Object[] arrayAllRegion = SwissProtExtraction.getAllRegion(swissProtContent);
        Object[] arrayAllSite = SwissProtExtraction.getAllSite(swissProtContent);
        ArrayList<String> listRegionSite = new ArrayList<String>();
        outputTextArea.append("Input: " + inputID + "\tAmino Acid Number: " + inputSequenceLength + "\n" + inputSequence + "\n");
        outputTextArea.append("Position\t" + "Residue\t");
        for (Object i : arrayAllRegion) {
            outputTextArea.append(i + "\t");
            listRegionSite.addAll(SwissProtExtraction.getRegion(swissProtContent, i, inputSequenceLength));
        }
        for (Object i : arrayAllSite) {
            outputTextArea.append(i + "\t");
            listRegionSite.addAll(SwissProtExtraction.getSite(swissProtContent, i, inputSequenceLength));
        }
        outputTextArea.append("\n");
        String[] arrayRegionSite = listRegionSite.toArray(new String[0]);
        for (int i = 0; i < inputSequenceLength; i++) {
            char eachResidue = inputSequence.charAt(i);
            outputTextArea.append(i + 1 + "\t" + eachResidue + "\t");
            for (int j = 0; j < (arrayRegionSite.length / inputSequenceLength); j++) {
                outputTextArea.append(arrayRegionSite[i + (j * inputSequenceLength)].replace("\t", ", ") + "\t");
            }
            outputTextArea.append("\n");
        }
    }

//Get AbDesigner
    private void getAbDesigner(String inputID, String swissProtContent, String segmaskerSequence, int spanSetting, int inputSequenceLength, int numberOfSpan) throws IOException {
        String inputSequence = segmaskerSequence.toUpperCase();
        int leftWingSpan = (spanSetting - 1) / 2;
        int rightWingSpan = spanSetting / 2;
        int endSpan = inputSequenceLength - rightWingSpan;
        System.out.println("leftWingSpan = " + leftWingSpan + " rightWingSpan = " + rightWingSpan + " endSpan = " + endSpan);
        int matchSpan = ((Integer) matchSpanSpinner.getValue()).intValue();
        //Get KD
        double[] arrayKD = KyteDoolittle.getArrayKyteDoolittle(inputSequence, spanSetting, inputSequenceLength, numberOfSpan);
        //Get modified CF
        Double[] arrayCF = ChouFasman.getArrayModifiedChouFasman(inputSequence, spanSetting, inputSequenceLength, numberOfSpan);
        //Get low-complexity sequence
        char[] segmaskerChar = new char[inputSequenceLength];
        for (int i = 0; i < segmaskerChar.length; i++) {
            segmaskerChar[i] = segmaskerSequence.charAt(i);
        }
        //Get Region/Site
        ArrayList<String> listRegionSite = new ArrayList<String>();
            //Get region
            Object[] arrayAllRegion = SwissProtExtraction.getAllRegion(swissProtContent);
            StringBuilder regionHeader = new StringBuilder();
            //Check TM
            boolean hasTM = false;
            int arrayTailLoop = 0;
            for (int i = 0; i < arrayAllRegion.length; i++) {
                listRegionSite.addAll(SwissProtExtraction.getRegion(swissProtContent, arrayAllRegion[i], inputSequenceLength));
                regionHeader.append(arrayAllRegion[i]).append("\t");
                //If arrayAllRegion has Transmembrane region
                if (arrayAllRegion[i].equals("Transmembrane region")) {
                    hasTM = true;
                    arrayTailLoop = i;
                }
            }
            //Get site
            Object[] arrayAllSite = SwissProtExtraction.getAllSite(swissProtContent);
            StringBuilder siteHeader = new StringBuilder();
            for (int i = 0; i < arrayAllSite.length; i++) {
                listRegionSite.addAll(SwissProtExtraction.getSite(swissProtContent, arrayAllSite[i], inputSequenceLength));
                siteHeader.append(arrayAllSite[i]).append("\t");
            }
        String[] arrayRegionSite = listRegionSite.toArray(new String[0]);
        //Get tail bonus
        double[] tailBonusArray = new double[inputSequenceLength];
        Arrays.fill(tailBonusArray, 1);
        if (hasTM) {
            tailBonusArray = TailBonus.getTailBonus(arrayRegionSite, arrayTailLoop, TAIL_BONUS, spanSetting, inputSequenceLength, numberOfSpan);
        }
        //Initialize arrays for arrIgScore, arrIgScoreMap, peptide, peptideStartRange, peptideEndRange, and structureArray
        double[] arrIgScore = new double[inputSequenceLength];
        TreeMap<Integer, Double> arrIgScoreMap = new TreeMap<Integer, Double>();
        String[] peptide = new String[inputSequenceLength];
        int[] peptideStartRange = new int[inputSequenceLength]; //Start from 1 (not from 0)
        int[] peptideEndRange = new int[inputSequenceLength];
        String[] structureArray = new String[inputSequenceLength];

        //Print Table 1
        outputTextArea.append("Input: " + inputID + "\tAmino Acid Number: " + inputSequenceLength + "\tPeptide Length: " + spanSetting + "\tEpitope Length: " + matchSpan + "\tTail Bonus: " + TAIL_BONUS + "\n" + inputSequence + "\n");
        outputTextArea.append("Position\t" + "Residue\t" + "Ig-score\t" + "Average hydropathy index\t" + "<Pa>\t" + "<Pb>\t" + "<Pt>\t" + "<pt>\t" + "Prediction\t" + "Average<Pa>\t" + "Average<Pb>\t" + "Average<Pt>\t" + "Average<pt>\t" + "Low-complexity sequence\t" + "Tail bonus\t" + regionHeader + siteHeader + "\n");
        outputTextArea.setCaretPosition(outputTextArea.getDocument().getLength());
        for (int i = 0; i < inputSequenceLength; i++) {
            char eachResidue = inputSequence.charAt(i);
            //Calculate IgScore
            double immunogenicityScore = ((arrayKD[i] * -1) + MAX_KD) * ((arrayCF[i + (7 * inputSequenceLength)])/100) * tailBonusArray[i];
            arrIgScore[i] = immunogenicityScore;
            arrIgScoreMap.put(i, immunogenicityScore);
            //Get peptide, peptideStartRange, and peptideEndRange
            if (i >= leftWingSpan && i < inputSequenceLength - rightWingSpan) {
                int startRange = i - leftWingSpan;
                int endRange = i + rightWingSpan + 1;
                peptide[i] = inputSequence.substring(startRange, endRange);
                peptideStartRange[i] = startRange + 1;
                peptideEndRange[i] = endRange;
            } else {
                peptide[i] = "";
            }
            int position = i + 1;
            //Print details per eachResidue
            outputTextArea.append(position + "\t" + eachResidue + "\t" + immunogenicityScore + "\t" + arrayKD[i] + "\t");
            //Print arrayCF
            for (int j = 0; j < (arrayCF.length / inputSequenceLength); j++) {
                if (j == 4) {
                    structureArray[i] = structure[arrayCF[i + (4 * inputSequenceLength)].intValue()];
                    outputTextArea.append(structureArray[i] + "\t");
                } else {
                    outputTextArea.append(arrayCF[i + (j * inputSequenceLength)] + "\t");
                }
            }
            //Print low-complexity sequence
            outputTextArea.append(segmaskerChar[i] + "\t");
            //Print tail bonus
            outputTextArea.append(tailBonusArray[i] + "\t");
            //Print arrayRegionSite
            for (int j = 0; j < (arrayRegionSite.length / inputSequenceLength); j++) {
                outputTextArea.append(arrayRegionSite[i + (j * inputSequenceLength)].replace("\t", ", ").replace("<br>", " ") + "\t");
            }
            outputTextArea.append("\n");
            outputTextArea.setCaretPosition(outputTextArea.getDocument().getLength());
        }
        //Prepare for heat map
        ArrayList<Map.Entry<Integer, Double>> arrIgScoreMapList = new ArrayList<Map.Entry<Integer, Double>>(arrIgScoreMap.entrySet());
        Comparator c1 = new Comparator<Map.Entry<Integer, Double>>() {
            public int compare(Map.Entry<Integer, Double> o1, Map.Entry<Integer, Double> o2) {
                return o1.getValue().compareTo(o2.getValue());
            }
        };
        //Sort arrIgScoreMapList<index, IgScore> based on IgScore (Sort Ascending: smallest to largest)
        //Double.NaN is considered by this method to be equal to itself and greater than all other double values
        Collections.sort(arrIgScoreMapList, c1); 
        double maxIgScore = arrIgScoreMapList.get(numberOfSpan - 1).getValue();
        double minIgScore = arrIgScoreMapList.get(0).getValue();
        //Get igScoreRank
        String[] igScoreRank = new String[inputSequenceLength];
        igScoreRank[arrIgScoreMapList.get(numberOfSpan - 1).getKey()] = Integer.toString(1);
        for (int i = numberOfSpan - 2; i >= 0; i--) {
            igScoreRank[arrIgScoreMapList.get(i).getKey()] =
                    (!arrIgScoreMapList.get(i).getValue().equals(arrIgScoreMapList.get(i + 1).getValue())) ?
                    Integer.toString(numberOfSpan - i) :
                    igScoreRank[arrIgScoreMapList.get(i + 1).getKey()];
        }
        double[] arrIgScoreHeatMap = new double[inputSequenceLength];
        double[] arrayKDHeatMap = new double[inputSequenceLength];
        double[] arrUniquenessHeatMapBlank = new double[inputSequenceLength];
        String[] allUniquenessMatchListBlank = new String[inputSequenceLength];
        Arrays.fill(allUniquenessMatchListBlank, "Pending...");
        double[] arrConservationHeatMapBlank = new double[inputSequenceLength];
        String[] allConservationMatchListBlank = new String[inputSequenceLength];
        Arrays.fill(allConservationMatchListBlank, "Pending...");
        String[] peptideClone = peptide.clone();
        //Transform values to 8-bit (0-255) scale
        for (int i = leftWingSpan; i < inputSequenceLength - rightWingSpan; i++) {
            arrIgScoreHeatMap[i] = (maxIgScore - minIgScore != 0) ?
                (arrIgScore[i] - minIgScore) * 255 / (maxIgScore - minIgScore) : 255;
            arrayKDHeatMap[i] = (arrayKD[i] * 127.5 / MAX_KD) + 127.5;
        }
        //Assign the same value as the first one evaluated
        for (int i = 0; i < leftWingSpan; i++) {
            arrIgScoreHeatMap[i] = arrIgScoreHeatMap[leftWingSpan];
            arrayKDHeatMap[i] = arrayKDHeatMap[leftWingSpan];
        }
        //Assign the same value as the last one evaluated
        for (int i = inputSequenceLength - rightWingSpan; i < inputSequenceLength; i++) {
            arrIgScoreHeatMap[i] = arrIgScoreHeatMap[inputSequenceLength - rightWingSpan - 1];
            arrayKDHeatMap[i] = arrayKDHeatMap[inputSequenceLength - rightWingSpan - 1];
        }
        //Display heat map
        HeatMap heatMap = new HeatMap(inputID, inputSequenceLength, spanSetting, segmaskerChar, arrIgScoreHeatMap, igScoreRank, arrUniquenessHeatMapBlank, allUniquenessMatchListBlank, arrConservationHeatMapBlank, allConservationMatchListBlank, peptideClone, arrayAllRegion, arrayAllSite, arrayRegionSite, hasTM, arrayTailLoop, arrayKDHeatMap, arrayKD, structureArray);

        //Print Table 2
        /** 
         *  Sort peptide, peptideStartRange, and peptideEndRange
         *  using sortedIndex based on IgScore (Sort Ascending: smallest to largest)
         *  Example: sortedArrays
         */
        String[] sortedPeptide = new String[inputSequenceLength];
        int[] sortedPeptideStartRange = new int[inputSequenceLength];
        int[] sortedPeptideEndRange = new int[inputSequenceLength];
        int[] sortedIndexArray = new int[inputSequenceLength];
        for (int i = 0; i < inputSequenceLength; i++) {
            int sortedIndex = arrIgScoreMapList.get(i).getKey();
            sortedPeptide[i] = peptide[sortedIndex];
            sortedPeptideStartRange[i] = peptideStartRange[sortedIndex];
            sortedPeptideEndRange[i] = peptideEndRange[sortedIndex];
            sortedIndexArray[i] = sortedIndex;
        }
        //Prepare an array containing matching peptides each located at position corresponding to its startRange
        int matchPerPeptide = spanSetting - matchSpan + 1;
        String[] arrMatch = new String[inputSequenceLength - matchSpan + 2]; //Example: arrMatch
        for (int i = 1; i < arrMatch.length; i++) {
            arrMatch[i] = inputSequence.substring(i - 1, i + matchSpan - 1).toUpperCase();
        }
        //Prepare entryName (gene_species)
        final String entryName = inputID;
        String species = (inputType != "FASTA") ? entryName.split("_")[1] : uniquenessSpecies.toString();
        String gene = (inputType != "FASTA") ? entryName.split("_")[0] : "input";
        //Prepare uniqueness database
        ArrayList<ArrayList<String>> uniquenessDatabase = getUniquenessDatabase(species); //Example: uniquenessDatabase
        //Prepare conservation database
        ArrayList<ArrayList<String>> conservationDatabase = getConservationDatabase(gene); //Example: conservationDatabase
        //Match
        int matchResultNumber = 0;
        String[][] arrUniquenessResults = new String[arrMatch.length][]; //Example: arrUniquenessResults
        String[][] arrConservationResults = new String[arrMatch.length][]; //Example: arrConservationResults
        progressLabel.setForeground(Color.blue);
        progressLabel.setText("Matching...");
        for (int i = 1; i < arrMatch.length; i++) {
            ArrayList<String> uniquenessMatchList = new ArrayList<String>();
            for (ArrayList<String> arrayList : uniquenessDatabase) {
                String locus = arrayList.get(0); //get(0) = locus
                if (!locus.equals(entryName)) { //Omit inputID
                    Pattern pattern = Pattern.compile(arrMatch[i]);
                    Matcher matcher = pattern.matcher(arrayList.get(1)); //get(1) = sequence
                    int matcherStart = 0;
                    /**
                     *  Resets this matcher and then attempts to find the next subsequence of the input sequence
                     *  that matches the pattern, starting at the next index from the start index of the previous match
                     */
                    while (matcher.find(matcherStart)) {
                        matcherStart = matcher.start() + 1;
                        uniquenessMatchList.add(locus + "\t" + i + "\t" + matcherStart + "\t" + matcher.group());
                    }
                }
            }
            arrUniquenessResults[i] = uniquenessMatchList.toArray(new String[0]);
            ArrayList<String> conservationMatchList = new ArrayList<String>();
            for (ArrayList<String> arrayList : conservationDatabase) {
                String locus = arrayList.get(0); //get(0) = locus
                if (!locus.equals(entryName)) { //Omit inputID
                    Pattern pattern = Pattern.compile(arrMatch[i]);
                    Matcher matcher = pattern.matcher(arrayList.get(1)); //get(1) = sequence
                    int matcherStart = 0;
                    /**
                     *  Resets this matcher and then attempts to find the next subsequence of the input sequence
                     *  that matches the pattern, starting at the next index from the start index of the previous match
                     */
                    while (matcher.find(matcherStart)) {
                        matcherStart = matcher.start() + 1;
                        conservationMatchList.add(locus + "\t" + i + "\t" + matcherStart + "\t" + matcher.group());
                    }
                }
            }
            arrConservationResults[i] = conservationMatchList.toArray(new String[0]);
            matchResultNumber++;
            jProgressBar.setValue(matchResultNumber * 100 / (arrMatch.length - 1));
        }
        //Initialize arrays for arrUniquenessNumber, allUniquenessMatchList, arrConservationNumber, and allConservationMatchList
        double[] arrUniquenessNumber = new double[inputSequenceLength];
        LinkedHashMap<Integer, Double> arrUniquenessNumberMap = new LinkedHashMap<Integer, Double>();
        String[] allUniquenessMatchList = new String[inputSequenceLength];
        double[] arrConservationNumber = new double[inputSequenceLength];
        LinkedHashMap<Integer, Double> arrConservationNumberMap = new LinkedHashMap<Integer, Double>();
        String[] allConservationMatchList = new String[inputSequenceLength];
        //Prepare blank peptide
        String blankPeptide = new String();
        for (int i = 0; i < spanSetting; i++) {
            blankPeptide += "-";
        }
        //Print details per each peptide
        outputTextArea.append("Range\t" + "Peptide\t" + "Ig-score\t" + "Uniqueness match number\t" + "Uniqueness match list\t" + "Conservation match number\t" + "Conservation match list\t" + regionHeader + siteHeader + "\n");
        for (int i = inputSequenceLength - 1; i >= 0; i--) {
            if (!sortedPeptide[i].isEmpty()) {
                ArrayList<String> uniquenessArrayList = new ArrayList<String>(); //Example: uniquenessArrayList
                ArrayList<String> conservationArrayList = new ArrayList<String>(); //Example: conservationArrayList
                for (int j = 0; j < matchPerPeptide; j++) { //For each matchSpan
                    String[] uniquenessResults = arrUniquenessResults[sortedPeptideStartRange[i] + j];
                    uniquenessArrayList.addAll(Arrays.asList(uniquenessResults));
                    String[] conservationResults = arrConservationResults[sortedPeptideStartRange[i] + j];
                    conservationArrayList.addAll(Arrays.asList(conservationResults));
                }
                LinkedHashSet<String> uniquenessMatchSet = new LinkedHashSet<String>(); //Example: uniquenessMatchSet
                TreeMap<String, Integer> uniquenessMatchMap = new TreeMap<String, Integer>();
                for (int j = 0; j < uniquenessArrayList.size(); j++) {
                    String[] strings = uniquenessArrayList.get(j).split("\t");
                    /**
                     * strings[0] = locus
                     * strings[1] = arrMatch index
                     * strings[2] = matched peptide start position
                     * strings[3] = matched peptide sequence
                     */
                    int relativeStartPosition = Integer.parseInt(strings[1]) - sortedPeptideStartRange[i];
                    /**
                     * Merge the results with the same locus, sequence, and relativeStartPosition
                     * Ignore matched peptide start position to avoid redundant count
                     */
                    uniquenessMatchSet.add(strings[0] + "_" + strings[3] + "_" + relativeStartPosition);
                    /**
                     * Tag the results with the same locus matched within the same peptide range with
                     * the same number (its start position - its relative distance from peptideStartRange)
                     */
                    String string = strings[0] + "_" + (Integer.parseInt(strings[2]) - relativeStartPosition);
                    uniquenessArrayList.set(j, uniquenessArrayList.get(j) + "\t" + string);
                    Integer freq = uniquenessMatchMap.get(string);
                    uniquenessMatchMap.put(string, (freq == null) ? 1 : freq + 1);
                }
                arrUniquenessNumber[i] = uniquenessMatchSet.size();
                //Create TreeMap<gene, number of non-redundant matched peptides> from uniquenessMatchSet
                TreeMap<String, Integer> uniquenessMatchNRMap = new TreeMap<String, Integer>(); //Example: uniquenessMatchNRMap
                for (String string : uniquenessMatchSet) {
                    String[] strings = string.split("_");
                    Integer freq = uniquenessMatchNRMap.get(strings[0]);
                    uniquenessMatchNRMap.put(strings[0], (freq == null) ? 1 : freq + 1);
                }
                LinkedHashSet<String> conservationMatchSet = new LinkedHashSet<String>(); //Example: conservationMatchSet
                TreeMap<String, Integer> conservationMatchMap = new TreeMap<String, Integer>();
                for (int j = 0; j < conservationArrayList.size(); j++) {
                    String[] strings = conservationArrayList.get(j).split("\t");
                    /**
                     * strings[0] = locus
                     * strings[1] = arrMatch index
                     * strings[2] = matched peptide start position
                     * strings[3] = matched peptide sequence
                     */
                    int relativeStartPosition = Integer.parseInt(strings[1]) - sortedPeptideStartRange[i];
                    /**
                     * Merge the results with the same locus, sequence, and relativeStartPosition
                     * Ignore matched peptide start position to avoid redundant count
                     */
                    conservationMatchSet.add(strings[0] + "_" + strings[3] + "_" + relativeStartPosition);
                    /**
                     * Tag the results with the same locus matched within the same peptide range with
                     * the same number (its start position - its relative distance from peptideStartRange)
                     */
                    String string = strings[0] + "_" + (Integer.parseInt(strings[2]) - relativeStartPosition);
                    conservationArrayList.set(j, conservationArrayList.get(j) + "\t" + string);
                    Integer freq = conservationMatchMap.get(string);
                    conservationMatchMap.put(string, (freq == null) ? 1 : freq + 1);
                }
                arrConservationNumber[i] = conservationMatchSet.size();
                //Create TreeMap<species, number of non-redundant matched peptides> from conservationMatchSet
                TreeMap<String, Integer> conservationMatchNRMap = new TreeMap<String, Integer>(); //Example: conservationMatchNRMap
                for (String string : conservationMatchSet) {
                    String[] strings = string.split("_");
                    Integer freq = conservationMatchNRMap.get(strings[1]);
                    conservationMatchNRMap.put(strings[1], (freq == null) ? 1 : freq + 1);
                }
                //Sort Map.Entry<String, Integer> based on Integer freq (Sort Descending: largest to smallest)
                ArrayList<Map.Entry<String, Integer>> uniquenessMatchMapList = new ArrayList<Map.Entry<String, Integer>>(uniquenessMatchMap.entrySet()); //Example: uniquenessMatchMapList
                ArrayList<Map.Entry<String, Integer>> conservationMatchMapList = new ArrayList<Map.Entry<String, Integer>>(conservationMatchMap.entrySet()); //Example: conservationMatchMapList
                ArrayList<Map.Entry<String, Integer>> uniquenessMatchNRMapList = new ArrayList<Map.Entry<String, Integer>>(uniquenessMatchNRMap.entrySet());
                ArrayList<Map.Entry<String, Integer>> conservationMatchNRMapList = new ArrayList<Map.Entry<String, Integer>>(conservationMatchNRMap.entrySet());
                Comparator c2 = new Comparator<Map.Entry<String, Integer>>() {
                    public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                        return o2.getValue().compareTo(o1.getValue());
                    }
                };
                Collections.sort(uniquenessMatchMapList, c2);
                Collections.sort(conservationMatchMapList, c2);
                Collections.sort(uniquenessMatchNRMapList, c2);
                Collections.sort(conservationMatchNRMapList, c2);
                //Create uniquenessMatchList
                StringBuilder uniquenessMatchList = new StringBuilder();
                for (Map.Entry<String, Integer> entry : uniquenessMatchNRMapList) {
                    int percentMatch = entry.getValue() * 100 / matchPerPeptide;
                    uniquenessMatchList.append(entry.getKey()).append(" [").append(percentMatch).append("%]; ");
                }
                //Create uniquenessMatchListToolTip
                StringBuilder uniquenessMatchListToolTip = new StringBuilder();
                uniquenessMatchListToolTip.append(sortedPeptide[i]).append(" ").append(sortedPeptideStartRange[i]).append("-").append(sortedPeptideEndRange[i]).append(" ").append(gene).append("<br>");
                for (int j = 0; j < uniquenessMatchMapList.size(); j++) {
                    String string = uniquenessMatchMapList.get(j).getKey();
                    StringBuilder mergedPeptide = new StringBuilder(blankPeptide);
                    TreeSet<Integer> treeSet = new TreeSet<Integer>();
                    for (int k = 0; k < matchPerPeptide; k++) {
                        for (int l = 0; l < uniquenessArrayList.size(); l++) {
                            String[] strings = uniquenessArrayList.get(l).split("\t");
                            if (strings[4].equals(string) && strings[1].equals(Integer.toString(sortedPeptideStartRange[i] + k))) {
                                mergedPeptide.replace(k, k + matchSpan, strings[3]);
                                treeSet.add(Integer.parseInt(strings[2]));
                                break;
                            }
                        }
                    }
                    if (j <= 10) {
                        uniquenessMatchListToolTip.append(mergedPeptide).append(" ").append(treeSet.first()).append("-").append(treeSet.last() + matchSpan - 1).append(" ").append(string.split("_")[0]).append("<br>");
                    } else {
                        uniquenessMatchListToolTip.append("...").append(uniquenessMatchMapList.size() - 10).append(" more matches");
                        break;
                    }
                }
                //Create conservationMatchList
                StringBuilder conservationMatchList = new StringBuilder();
                for (Map.Entry<String, Integer> entry : conservationMatchNRMapList) {
                    int percentMatch = entry.getValue() * 100 / matchPerPeptide;
                    conservationMatchList.append(entry.getKey()).append(" [").append(percentMatch).append("%]; ");
                }
                //Create conservationMatchListToolTip
                StringBuilder conservationMatchListToolTip = new StringBuilder();
                conservationMatchListToolTip.append(sortedPeptide[i]).append(" ").append(sortedPeptideStartRange[i]).append("-").append(sortedPeptideEndRange[i]).append(" ").append(species).append("<br>");
                for (int j = 0; j < conservationMatchMapList.size(); j++) {
                    String string = conservationMatchMapList.get(j).getKey();
                    StringBuilder mergedPeptide = new StringBuilder(blankPeptide);
                    TreeSet<Integer> treeSet = new TreeSet<Integer>();
                    for (int k = 0; k < matchPerPeptide; k++) {
                        for (int l = 0; l < conservationArrayList.size(); l++) {
                            String[] strings = conservationArrayList.get(l).split("\t");
                            if (strings[4].equals(string) && strings[1].equals(Integer.toString(sortedPeptideStartRange[i] + k))) {
                                mergedPeptide.replace(k, k + matchSpan, strings[3]);
                                treeSet.add(Integer.parseInt(strings[2]));
                                break;
                            }
                        }
                    }
                    if (j <= 10) {
                        conservationMatchListToolTip.append(mergedPeptide).append(" ").append(treeSet.first()).append("-").append(treeSet.last() + matchSpan - 1).append(" ").append(string.split("_")[1]).append("<br>");
                    } else {
                        conservationMatchListToolTip.append("...").append(conservationMatchMapList.size() - 10).append(" more matches");
                        break;
                    }
                }
                //Start actual reporting
                outputTextArea.append(sortedPeptideStartRange[i] + ".." + sortedPeptideEndRange[i] + "\t" + sortedPeptide[i] + "\t" + arrIgScoreMapList.get(i).getValue() + "\t" + arrUniquenessNumber[i] + "\t" + uniquenessMatchList + "\t" + arrConservationNumber[i] + "\t" + conservationMatchList + "\t");
                arrUniquenessNumberMap.put(sortedIndexArray[i], arrUniquenessNumber[i]);
                allUniquenessMatchList[i] = uniquenessMatchListToolTip.toString();
                arrConservationNumberMap.put(sortedIndexArray[i], arrConservationNumber[i]);
                allConservationMatchList[i] = conservationMatchListToolTip.toString();
                for (int j = 0; j < (arrayRegionSite.length / inputSequenceLength); j++) { //For each region/site
                    StringBuilder allRegionSite = new StringBuilder();
                    for (int k = sortedPeptideStartRange[i] - 1; k < sortedPeptideEndRange[i]; k++) { //Get allRegionSite of each peptide
                        allRegionSite.append(arrayRegionSite[k + (j * inputSequenceLength)]).append("\t");
                    }
                    //Eliminate redundancy and Put overlapping notes together separated by ,
                    LinkedHashSet<String> setRegionSite = new LinkedHashSet<String>();
                    String[] arrayAllRegionSite = allRegionSite.toString().split("\t");
                    for (String eachRegionSite : arrayAllRegionSite) {
                        if (!eachRegionSite.equals(" ")) {
                            setRegionSite.add(eachRegionSite);
                        }
                    }
                    if (setRegionSite.isEmpty()) {
                        outputTextArea.append(" \t");
                    } else {
                        StringBuilder cleanRegionSite = new StringBuilder();
                        for (Object eachRegionSite : setRegionSite) {
                            cleanRegionSite.append(eachRegionSite).append(", ");
                        }
                        outputTextArea.append(cleanRegionSite.substring(0, cleanRegionSite.length() - 2).replace("<br>", " ") + "\t");
                    }
                }
                outputTextArea.append("\n");
                outputTextArea.setCaretPosition(outputTextArea.getDocument().getLength());
            }
        }
        //Sort arrUniquenessNumberMapList based on UniquenessNumber (Sort Ascending: smallest to largest)
        ArrayList<Map.Entry<Integer, Double>> arrUniquenessNumberMapList = new ArrayList<Map.Entry<Integer, Double>>(arrUniquenessNumberMap.entrySet());
        Collections.sort(arrUniquenessNumberMapList, c1);
        String[][] arr2DUniqueness = new String[numberOfSpan][4];
        for (int i = 0; i < numberOfSpan; i++) {
            int sortedIndex = arrUniquenessNumberMapList.get(i).getKey();
            //Uniqueness Rank
            if (i != 0) {
                arr2DUniqueness[i][0] =
                        (arrUniquenessNumberMapList.get(i).getValue().equals(arrUniquenessNumberMapList.get(i - 1).getValue()) &&
                        arrIgScore[sortedIndex] == arrIgScore[arrUniquenessNumberMapList.get(i - 1).getKey()]) ?
                        arr2DUniqueness[i - 1][0] :
                        Integer.toString(i + 1);
            } else {
                arr2DUniqueness[i][0] = Integer.toString(1);
            }
            arr2DUniqueness[i][1] = peptide[sortedIndex];
            arr2DUniqueness[i][2] = Integer.toString(peptideStartRange[sortedIndex]);
            arr2DUniqueness[i][3] = Integer.toString(peptideEndRange[sortedIndex]);
            System.out.println("Uniqueness Rank = " + arr2DUniqueness[i][0] +
                    " peptide = " + arr2DUniqueness[i][1] +
                    " " + arr2DUniqueness[i][2] +
                    " " + arr2DUniqueness[i][3]);
        }
        double maxUniquenessNumber = UNIQUENESS_NUMBER * matchPerPeptide; //Real max = arrUniquenessNumberMapList.get(numberOfSpan - 1).getValue();
        double minUniquenessNumber = 0;
        System.out.println("maxUniquenessNumber: " + maxUniquenessNumber + " minUniquenessNumber: " + minUniquenessNumber);
        //Sort arrConservationNumberMapList based on ConservationNumber (Sort Descending: largest to smallest)
        ArrayList<Map.Entry<Integer, Double>> arrConservationNumberMapList = new ArrayList<Map.Entry<Integer, Double>>(arrConservationNumberMap.entrySet());
        Comparator c3 = new Comparator<Map.Entry<Integer, Double>>() {
            public int compare(Map.Entry<Integer, Double> o1, Map.Entry<Integer, Double> o2) {
                return o2.getValue().compareTo(o1.getValue());
            }
        };
        Collections.sort(arrConservationNumberMapList, c3);
        String[][] arr2DConservation = new String[numberOfSpan][4];
        for (int i = 0; i < numberOfSpan; i++) {
            int sortedIndex = arrConservationNumberMapList.get(i).getKey();
            //Conservation Rank
            if (i != 0) {
                arr2DConservation[i][0] =
                        (arrConservationNumberMapList.get(i).getValue().equals(arrConservationNumberMapList.get(i - 1).getValue()) &&
                        arrIgScore[sortedIndex] == arrIgScore[arrConservationNumberMapList.get(i - 1).getKey()]) ?
                        arr2DConservation[i - 1][0] :
                        Integer.toString(i + 1);
            } else {
                arr2DConservation[i][0] = Integer.toString(1);
            }
            arr2DConservation[i][1] = peptide[sortedIndex];
            arr2DConservation[i][2] = Integer.toString(peptideStartRange[sortedIndex]);
            arr2DConservation[i][3] = Integer.toString(peptideEndRange[sortedIndex]);
            System.out.println("Conservation Rank = " + arr2DConservation[i][0] +
                    " peptide = " + arr2DConservation[i][1] +
                    " " + arr2DConservation[i][2] +
                    " " + arr2DConservation[i][3]);
        }
        double maxConservationNumber = (SPECIES_NUMBER - 1) * matchPerPeptide;
        double minConservationNumber = 0;
        System.out.println("maxConservationNumber: " + maxConservationNumber + " minConservationNumber: " + minConservationNumber);
        //Sort arrays back in ascending index order (based on sortedIndex)
        double[] sortedArrUniquenessNumber = new double[inputSequenceLength];
        String[] sortedAllUniquenessMatchList = new String[inputSequenceLength];
        double[] sortedArrConservationNumber = new double[inputSequenceLength];
        String[] sortedAllConservationMatchList = new String[inputSequenceLength];
        for (int i = 0; i < inputSequenceLength; i++) {
            int sortedIndex = sortedIndexArray[i];
            sortedArrUniquenessNumber[sortedIndex] = arrUniquenessNumber[i];
            sortedAllUniquenessMatchList[sortedIndex] = allUniquenessMatchList[i];
            sortedArrConservationNumber[sortedIndex] = arrConservationNumber[i];
            sortedAllConservationMatchList[sortedIndex] = allConservationMatchList[i];
        }
        //Transform values to 8-bit (0-255) scale
        double[] arrUniquenessHeatMap = new double[inputSequenceLength];
        double[] arrConservationHeatMap = new double[inputSequenceLength];
        for (int i = leftWingSpan; i < inputSequenceLength - rightWingSpan; i++) {
            arrUniquenessHeatMap[i] = (sortedArrUniquenessNumber[i] > maxUniquenessNumber) ?
                0 : 255 - ((sortedArrUniquenessNumber[i] * 255) / maxUniquenessNumber);
            arrConservationHeatMap[i] = (sortedArrConservationNumber[i] * 255) / maxConservationNumber;
        }
        for (int i = 0; i < leftWingSpan; i++) {
            arrUniquenessHeatMap[i] = arrUniquenessHeatMap[leftWingSpan];
            arrConservationHeatMap[i] = arrConservationHeatMap[leftWingSpan];
        }
        for (int i = inputSequenceLength - rightWingSpan; i < inputSequenceLength; i++) {
            arrUniquenessHeatMap[i] = arrUniquenessHeatMap[inputSequenceLength - rightWingSpan - 1];
            arrConservationHeatMap[i] = arrConservationHeatMap[inputSequenceLength - rightWingSpan - 1];
        }
        //Update heat map
        heatMap.updateData(arrUniquenessHeatMap, sortedAllUniquenessMatchList, arrConservationHeatMap, sortedAllConservationMatchList);
    }

    private void readDatabase() throws IOException, ClassNotFoundException {
        //Read from AbDesigner database [.ab]
        progressLabel.setForeground(Color.blue);
        progressLabel.setText("Reading accessionLocusMap...");
        accessionLocusMap = Database.getAccessionLocusMap();
        progressLabel.setText("Reading geneLocusMap...");
        geneLocusMap = Database.getGeneLocusMap();
        progressLabel.setText("Reading locusFeaturesMap...");
        locusFeaturesMap = Database.getLocusFeaturesMap();
        progressLabel.setText("Reading locusSegmaskerMap...");
        locusSegmaskerMap = Database.getLocusSegmaskerMap();
        progressLabel.setText("Reading human2DArrayList...");
        human2DArrayList = Database.getLocusSequence2DArrayList("human");
        progressLabel.setText("Reading rat2DArrayList...");
        rat2DArrayList = Database.getLocusSequence2DArrayList("rat");
        progressLabel.setText("Reading mouse2DArrayList...");
        mouse2DArrayList = Database.getLocusSequence2DArrayList("mouse");
        databaseLoaded = true;
        progressLabel.setForeground(Color.red);
        progressLabel.setText("All databases are loaded");
    }

    private ArrayList<ArrayList<String>> getUniquenessDatabase(String species) {
        ArrayList<ArrayList<String>> uniquenessDatabase = null;
        if (species.equals("HUMAN")) {
            uniquenessDatabase = human2DArrayList;
        } else if (species.equals("RAT")) {
            uniquenessDatabase = rat2DArrayList;
        } else if (species.equals("MOUSE")) {
            uniquenessDatabase = mouse2DArrayList;
        }
        return uniquenessDatabase;
    }

    private ArrayList<ArrayList<String>> getConservationDatabase(String gene) {
        ArrayList<ArrayList<String>> conservationDatabase = new ArrayList<ArrayList<String>>();
        String humanEntryName = gene + "_HUMAN";
        String ratEntryName = gene + "_RAT";
        String mouseEntryName = gene + "_MOUSE";
        String humanSequence = locusSegmaskerMap.get(humanEntryName);
        String ratSequence = locusSegmaskerMap.get(ratEntryName);
        String mouseSequence = locusSegmaskerMap.get(mouseEntryName);
        if (humanSequence != null) {
            ArrayList<String> arrayList = new ArrayList<String>();
            arrayList.add(humanEntryName);
            arrayList.add(humanSequence.toUpperCase());
            conservationDatabase.add(arrayList);
        }
        if (ratSequence != null) {
            ArrayList<String> arrayList = new ArrayList<String>();
            arrayList.add(ratEntryName);
            arrayList.add(ratSequence.toUpperCase());
            conservationDatabase.add(arrayList);
        }
        if (mouseSequence != null) {
            ArrayList<String> arrayList = new ArrayList<String>();
            arrayList.add(mouseEntryName);
            arrayList.add(mouseSequence.toUpperCase());
            conservationDatabase.add(arrayList);
        }
        return conservationDatabase;
    }

}
